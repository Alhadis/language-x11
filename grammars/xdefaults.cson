name: "X Resource Defaults"
scopeName: "source.xdefaults"
fileTypes: [
	"XErrorDB"
	"Xdefaults"
	"xdm-config"
	"xrdb"
	"Xres"
	"Xresources"
	"X11/app-defaults/*"
]
firstLineMatch: """(?x)
	# RCS revision comment prefixed by “XFree86:”
	\\A!\\x20\\$XFree86:.*\\$$

	|

	# Emacs modeline
	-\\*-(?i:[ \\t]*(?=[^:;\\s]+[ \\t]*-\\*-)|(?:.*?[ \\t;]|(?<=-\\*-))[ \\t]*mode[ \\t]*:[ \\t]*)
		(?i:conf-xdefaults)
	(?=[ \\t;]|(?<![-*])-\\*-).*?-\\*-

	|

	# Vim modeline
	(?:(?:^|[ \\t])(?:vi|Vi(?=m))(?:m[<=>]?[0-9]+|m)?|[ \\t]ex)(?=:(?=[ \\t]*set?[ \\t][^\\r\\n:]+:)|:(?![ \\t]*set?[ \\t]))
	(?:(?:[ \\t]*:[ \\t]*|[ \\t])\\w*(?:[ \\t]*=(?:[^\\\\\\s]|\\\\.)*)?)*[ \\t:]
	(?:filetype|ft|syntax)[ \\t]*=
		(?i:xdefaults)
	(?=$|\\s|:)
"""
patterns: [include: "#main"]

repository:
	main:
		patterns: [
			{include: "#comment"}
			{include: "#pragmata"}
			{include: "#resource"}
		]

	# Boolean keyword
	boolean:
		match: "(?i)\\G\\s*(?:(on|true|yes)|(off|no|false))(?=\\s*$)"
		captures:
			1: name: "constant.language.boolean.true.xdefaults"
			2: name: "constant.language.boolean.false.xdefaults"


	# Colour value, specified numerically or by name
	colour:
		patterns: [{
			# RGB device specification: “rgb:<hex>/<hex>/<hex>”
			name: "meta.colour-specification.rgb-device.xdefaults"
			match: """(?xi) \\G
				(rgb(:))
				([0-9A-F]{1,4}) (/)
				([0-9A-F]{1,4}) (/)
				([0-9A-F]{1,4}) \\b
				(?=\\s*$)
			"""
			captures:
				1: name: "storage.type.colour-space.xdefaults"
				2: name: "punctuation.definition.colour.xdefaults"
				3: patterns: [include: "#colourRed"]
				5: patterns: [include: "#colourGreen"]
				7: patterns: [include: "#colourBlue"]
				4: patterns: [include: "#colourSlash"]
				6: patterns: [include: "#colourSlash"]
		},{
			# RGB intensity specification: “rgbi:<float>/<float>/<float>”
			name: "meta.colour-specification.rgb-intensity.xdefaults"
			match: "(?i)\\G(rgbi(:))((?:(?:(?<=:)|(/))[-+]?[0-9]+(?:\\.[0-9]+)?(?:e[-+]?[0-9]+)?){3})(?=\\s*$)"
			captures:
				1: name: "storage.type.colour-space.xdefaults"
				2: name: "punctuation.definition.colour.xdefaults"
				3: patterns: [{
					# Floating-point RGB values: 0.0–1.0
					match: "\\G([^/]+)(/)([^/]+)(/)([^/]+)"
					captures:
						1: name: "constant.numeric.float.decimal.colour-component.red.xdefaults"
						3: name: "constant.numeric.float.decimal.colour-component.green.xdefaults"
						5: name: "constant.numeric.float.decimal.colour-component.blue.xdefaults"
						2: patterns: [include: "#colourSlash"]
						4: patterns: [include: "#colourSlash"]
				}]
		},{
			# Device-independent colour expressed in arbitrary colour space
			name: "meta.colour-specification.${2:/downcase}.xdefaults"
			match: "(?i)\\G(?!rgbi?)(([A-Z]+)(:)((?:(?:(?<=:)|(/))[-+]?[0-9]+(?:\\.[0-9]+)?(?:e[-+]?[0-9]+)?){3})(?=\\s*$))"
			captures:
				1: name: "storage.type.colour-space.xdefaults"
				3: name: "punctuation.definition.colour.xdefaults"
				4: patterns: [{
					# Floating-point XYZ/CIE/WTF/ETC component
					name: "constant.numeric.float.decimal.colour-component.xdefaults"
					match: "[-+]?\\d+(?:\\.\\d+)?(?:[Ee][-+]?\\d+)?\\b"
				}, include: "#colourSlash"]
		},{
			# RGB device specification (Legacy syntax)
			match: """(?xi) \\G
				(?: ((\\#) ([A-F0-9]{4}) ([A-F0-9]{4}) ([A-F0-9]{4}))  #RRRRGGGGBBBB (16-bits each)
				|   ((\\#) ([A-F0-9]{3}) ([A-F0-9]{3}) ([A-F0-9]{3}))  #RRRGGGBBB    (12-bits each)
				|   ((\\#) ([A-F0-9]{2}) ([A-F0-9]{2}) ([A-F0-9]{2}))  #RRGGBB       (8-bits each)
				|   ((\\#) ([A-F0-9])    ([A-F0-9])    ([A-F0-9]))     #RGB          (4-bits each)
				) \\b(?=\\s*$)
			"""
			captures:
				1:  name: "meta.colour-specification.rgb-device.legacy.16-bit.xdefaults"
				2:  patterns: [include: "#colourHash"]
				3:  patterns: [include: "#colourRed"]
				4:  patterns: [include: "#colourGreen"]
				5:  patterns: [include: "#colourBlue"]

				6:  name: "meta.colour-specification.rgb-device.legacy.12-bit.xdefaults"
				7:  patterns: [include: "#colourHash"]
				8:  patterns: [include: "#colourRed"]
				9:  patterns: [include: "#colourGreen"]
				10: patterns: [include: "#colourBlue"]

				11: name: "meta.colour-specification.rgb-device.legacy.8-bit.xdefaults"
				12: patterns: [include: "#colourHash"]
				13: patterns: [include: "#colourRed"]
				14: patterns: [include: "#colourGreen"]
				15: patterns: [include: "#colourBlue"]

				16: name: "meta.colour-specification.rgb-device.legacy.4-bit.xdefaults"
				17: patterns: [include: "#colourHash"]
				18: patterns: [include: "#colourRed"]
				19: patterns: [include: "#colourGreen"]
				20: patterns: [include: "#colourBlue"]
		},{
			# Named colour that matches entire string
			applyEndPatternLast: yes
			begin: "\\G(?=[a-zA-Z])(?!(?:[^\\\\]|\\\\.)*+\\\\$)"
			end:   "\\b(?![-*+])[^\\r\\n]*"
			patterns: [include: "source.x11-colours#names"]
			endCaptures: 0:
				name: "string.unquoted.xdefaults"
				patterns: [include: "#esc"]
		}]

	# Stuff matched inside a tokenised colour specification
	colourHash:  {match: "#",    name: "punctuation.definition.constant.colour.xdefaults"}
	colourSlash: {match: "/",    name: "punctuation.separator.colour-components.xdefaults"}
	colourRed:   {match: "\\S+", name: "constant.numeric.integer.hexadecimal.colour-component.red.xdefaults"}
	colourGreen: {match: "\\S+", name: "constant.numeric.integer.hexadecimal.colour-component.green.xdefaults"}
	colourBlue:  {match: "\\S+", name: "constant.numeric.integer.hexadecimal.colour-component.blue.xdefaults"}


	# Comment line, introduced by an exclamation mark in the first column
	# NB: According to Vim's “xdefaults.vim” syntax, C-style comments should be ignored by xrdb(1);
	# however, this is undocumented functionality reported from ~2006, and it's wise to assume this
	# isn't set in stone. Hence, we only support the standard comment syntax.
	comment:
		name:  "comment.line.bang.exclamation-mark.xdefaults"
		begin: "^!"
		end:   "$"
		beginCaptures:
			0: name: "punctuation.definition.comment.xdefaults"


	# Escape sequences recognised within resource values
	esc:
		patterns: [{
			# Escaped backslash
			name:  "constant.character.escape.backslash.xdefaults"
			match: "(\\\\)\\\\"
			captures:
				1: name: "punctuation.definition.escape.backslash.xdefaults"
		},{
			# Character specified by its octal character code
			name:  "constant.character.escape.codepoint.octal.xdefaults"
			match: "(\\\\)[0-7]{3}"
			captures:
				1: name: "punctuation.definition.escape.backslash.xdefaults"
		},{
			# Escaped space or horizontal tab character
			name:  "constant.character.escape.whitespace.xdefaults"
			match: "(\\\\)[ \\t]"
			captures:
				1: name: "punctuation.definition.escape.backslash.xdefaults"
		},{
			# Embedded newline character
			name:  "constant.character.escape.newline.xdefaults"
			match: "(\\\\)n"
			captures:
				1: name: "punctuation.definition.escape.backslash.xdefaults"
		},{
			# Line continuation; unlike ‘\n’, will be removed from the final value
			name:  "constant.character.escape.line-continuation.xdefaults"
			begin: "(\\\\)$[ \\r\\n]?"
			end:   "^"
			beginCaptures:
				1: name: "punctuation.definition.escape.backslash.xdefaults"
		}]


	# C-like preprocessor directives
	pragmata:
		patterns: [{
			# Embed another X resources file
			name:  "meta.preprocessor.include.xdefaults"
			begin: "^(#)\\s*include[ \\s]*"
			end:   "(?=\\s*$)"
			beginCaptures:
				0: name: "keyword.control.directive.include.xdefaults"
				1: name: "punctuation.definition.directive.xdefaults"
			contentName: "string.other.link.filename.xdefaults"
		},{
			# Blocks of code commented-out using “#if 0”
			include: "source.c#preprocessor-rule-disabled-block"
		},{
			# Conditional: “#if COND … [#elsif COND] … #endif”
			begin: "^((#)\\s*(if(?:n?def)?))(?=$|\\s)(\\s+[^\\r\\n].*$)?"
			end:   "^((#)\\s*endif)(?=$|\\s)"
			beginCaptures:
				0: name: "meta.preprocessor.conditional.$3.xdefaults"
				1: name: "keyword.control.directive.conditional.xdefaults"
				2: name: "punctuation.definition.directive.xdefaults"
				4: patterns: [include: "source.c#preprocessor-rule-conditional-line"]
			endCaptures:
				0: name: "meta.preprocessor.conditional.endif.xdefaults"
				1: name: "keyword.control.directive.conditional.xdefaults"
				2: name: "punctuation.definition.directive.xdefaults"
			patterns: [{
				name: "meta.preprocessor.conditional.$3.xdefaults"
				match: "^((#)\\s*(elif|else))(?=$|\\s)(\\s+[^\\r\\n].*$)?"
				captures:
					1: name: "keyword.control.directive.conditional.xdefaults"
					2: name: "punctuation.definition.directive.xdefaults"
					4: patterns: [include: "source.c#preprocessor-rule-conditional-line"]
			}, include: "#main"]
		},{
			# Define a constant or function-like macro
			name:  "meta.preprocessor.macro.xdefaults"
			begin: "^((#)\\s*(define|undef))\\s+(?!\\d)([\\w$]+)((\\()([\\w$,\\s]*(?:\\.{3})?)(\\)))?"
			end:   "\\s*(//[^\\r\\n]*|/\\*.*\\*/)|(?<!\\\\)$"
			patterns: [
				{include: "source.c#preprocessor-rule-define-line-contents"}
				{include: "source.c"}
			]
			contentName: "source.embedded.c"
			beginCaptures:
				1: name: "keyword.control.directive.$3.xdefaults"
				2: name: "punctuation.definition.directive.xdefaults"
				4: name: "entity.name.function.preprocessor.xdefaults"
				5: name: "meta.parameters.xdefaults"
				6: name: "punctuation.definition.parameters.begin.xdefaults"
				8: name: "punctuation.definition.parameters.end.xdefaults"
				7: patterns: [
					{match: ",",       name: "punctuation.separator.parameters.comma.xdefaults"}
					{match: "[\\w$]+", name: "variable.parameter.preprocessor.xdefaults"}
					{include: "source.c#vararg_ellipses"}
				]
			endCaptures:
				1: patterns: [include: "source.c#comments"]
		},{
			# Other pragma directives with questionable usage
			name:  "meta.preprocessor.$3.xdefaults"
			begin: "^((#)\\s*(error|line|pragma|warning|warn))(?=$|\\s)"
			end:   "\\s*(//[^\\r\\n]*|/\\*.*\\*/)|(?<!\\\\)$"
			beginCaptures:
				1: name: "keyword.control.directive.$3.xdefaults"
				2: name: "punctuation.definition.directive.xdefaults"
			endCaptures:
				1: patterns: [include: "source.c#comments"]
			contentName: "source.embedded.c"
			patterns: [{
				begin: "(?<=pragma)\\G"
				end:   "(?=\\s*(?://|/\\*))|(?<!\\\\)$"
				patterns: [{
					# Unquoted keyword
					name: "entity.other.attribute-name.pragma.preprocessor.c"
					match: "(?!-|\\d)[-\\w$]+"
				}, include: "#pragmaInnards"]
			}, include: "#pragmaInnards"]
		}]

	# Stuff matched inside miscellaneous preprocessor directives
	pragmaInnards:
		patterns: [
			{include: "#esc"}
			{include: "source.c#numbers"}
			{include: "source.c#strings"}
		]


	# X logical font description
	font:
		match: "\\G\\s*([*-][^\\s\\\\]+)$"
		captures:
			1: patterns: [include: "source.xlfd#name"]


	# Geometry specification: WxH±X±Y
	geometry:
		name: "meta.geometry.xdefaults"
		match: """(?xi) (?:\\G|^|(?<=\\s|:)) \\s*
			(?=\\d|-|\\+)

			# $1: Dimensions
			(
				(\\d+)  # $2: Width
				(x)     # $3: Separator
				(\\d+)  # $4: Height
			)?

			# $5: Position, relative to different edges depending on -/+ prefix
			(
				# X-offset
				(?: ((\\+) ([-+]?\\d+)) # $6–$8:  From left-edge of screen
				|   ((-)   ([-+]?\\d+)) # $9–$11: From right-edge of screen
				)

				# Y-offset
				(?: ((\\+) ([-+]?\\d+)) # $12-14: From top-edge of screen
				|   ((-)   ([-+]?\\d+)) # $15-17: From bottom-edge of screen
				)
			)?
			(?<=\\d)
			(?=$|\\s)
		"""
		captures:
			1:  name: "constant.numeric.dimensions.xdefaults"
			2:  name: "constant.numeric.dimension.width.xdefaults"
			3:  name: "punctuation.separator.dimensions.xdefaults"
			4:  name: "constant.numeric.dimension.height.xdefaults"

			5:  name: "constant.numeric.position.xdefaults"
			6:  name: "meta.geometry.position.x-offset.from-left.xdefaults"
			7:  name: "punctuation.definition.offset.screen-edge.xdefaults"
			8:  name: "constant.numeric.offset.xdefaults"

			9:  name: "meta.geometry.position.x-offset.from-right.xdefaults"
			10: name: "punctuation.definition.offset.screen-edge.xdefaults"
			11: name: "constant.numeric.offset.xdefaults"

			12: name: "meta.geometry.position.y-offset.from-top.xdefaults"
			13: name: "punctuation.definition.offset.screen-edge"
			14: name: "constant.numeric.offset.xdefaults"

			15: name: "meta.geometry.position.y-offset.from-bottom.xdefaults"
			16: name: "punctuation.definition.offset.screen-edge"
			17: name: "constant.numeric.offset.xdefaults"


	# Plain-old numeric literals
	number:
		patterns: [{
			# Floating-point
			name: "constant.numeric.float.decimal.xdefaults"
			match: "\\G[-+]?\\d+(?:\\.\\d+)?(?:[Ee][-+]?\\d+)?(?=\\s*$)"
		},{
			# Integer
			name: "constant.numeric.integer.decimal.xdefaults"
			match: "\\G[-+]?\\d+(?=\\s*$)"
		}]


	# X resource specification
	resource:
		name:  "meta.resource.xdefaults"
		begin: "^\\s*([.*]?(?:(?:\\?|(?!\\s)[^?.*:]+)[.*])*(?!\\s)[^?.*:]+)(?<!\\s)\\s*(:)[ \\t]*"
		end:   "(?<!\\\\)$"
		beginCaptures:
			1: patterns: [{
				# Loose binding
				name: "keyword.operator.binding.loose.xdefaults"
				match: "\\*"
				captures:
					0: name: "punctuation.separator.asterisk.binding.xdefaults"
			},{
				# Tight binding
				name: "keyword.operator.binding.tight.xdefaults"
				match: "\\."
				captures:
					0: name: "punctuation.separator.period.binding.xdefaults"
			},{
				# Wildcard
				name: "keyword.operator.wildcard.xdefaults"
				match: "\\?"
			},{
				# Component name
				name: "entity.name.tag.component.xdefaults"
				match: "(?!\\s)[^?.*:]+"
			}]
			2: name: "keyword.operator.assignment.xdefaults"
		patterns: [include: "#value"]


	# Treat values without an obvious syntax/type as strings
	string:
		name:  "string.unquoted.xdefaults"
		begin: "\\G(?=\\S)"
		end:   "(?<!\\\\)$"
		patterns: [include: "#esc"]


	# Stuff matched inside a resource value
	value:
		patterns: [
			{include: "#geometry"}
			{include: "#number"}
			{include: "#font"}
			{include: "#boolean"}
			{include: "#colour"}
			{include: "#string"}
		]
